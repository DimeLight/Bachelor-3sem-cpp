
# Задача
составить программы табулирования заданной функции в заданном интервале с заданным шагом:
+ Программа 1

Используя парадигму структурного программирования в терминах языка C++ с функцией записи в файл.
+ Программа 2

Используя ООП: исходные данные читаются из файла в формате txt, программа рассчитывает значение заданной функции с помощью иерархии классов и записывает точки табуляции в другой файл.
+ Программа 3

Разработка графического интерфейса пользователя с использованием инструментария Windows Forms и реализации функции табулирования в виде иерархии классов в рамках интерфейса Windows Forms с выводом в график (инструмент chart).

Нам выдали функции вот мой вариант:
y(x)=√(x/(4 ln⁡x ))

вычислил Область Допустимых Значений функции (т.к. тестировщика в проекте нет - будет работать математика):

ОДЗ функции обусловлена присутствием аргумента функции x:

под знаком корня

√x  ⇒ x ≥ 0

под знаком корня в знаменателе дроби в функции натурального логарифма

√( 1 / ln⁡x )  ⇒ 1 / ln⁡x ≥ 0 ⇒ ln⁡x > 0 ⇒ x > 1

Поскольку подкоренное выражение не может быть отрицательно, то значение знаменателя подкоренного выражения строго положительно ( f(x) > 0 ). Значение знаменателя подкоренного выражения f(x) = ln⁡x = 0 при x = 1, следовательно x > 1:

В совокупности:
{x∈R:x>1}

Область Определения Функции:

Стационарные точки:

y(x)<sup>I</sup> = ( √( x / ln⁡x ) / 2 )<sup>I</sup> = 1 / 2 ∙ ( √( x / ln⁡x ) )<sup>I</sup> = 1 / ( 4 √( x / ln⁡x ) ) ( x / ln⁡x )<sup>I</sup> = 1 / ( 4 √( x / ln⁡x ) ) ∙ ( x<sup>I</sup> ∙ ln⁡x -(ln⁡x)<sup>I</sup> ∙ x ) / ln⁡x = ( ln⁡x - 1 ) / ( 4 √( x / ln⁡x ) ln^(2⁡x) ) = 0

x = e – точка минимума.

Минимальное значение функция принимает в:

y(e) = √( e / ( 4 ln⁡e ) ) = √e / 2

Следовательно:

{y∈R:y≥√e/2}

### График функции:

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/800c81fa-2e44-4842-a643-169ebf95608c)

Рисунок 1 – график функции

# Самое интересное – Детали реализации
## Сообщения
### В поставленной задаче существуют вводные данные, которые не должны существовать (Н: «1/2/3/4», «АБВгдеёж»). Следовательно программа должна уведомить об этом пользователя.
## Шаг как модуль
### Термин «шаг табуляции функции» можно интерпретировать, применимо к интервалу табуляции функции, как его абсолютная часть, и, при вводе «отрицательного» (от большей точки к меньшей) интервала можно табулировать с шагом отрицательного значения, но положительного модуля относительно интервала. Следовательно, при вводе положительного значения шага программа при выполнении табуляции меняет его знак на отрицательный (и наоборот), если интервал задан от большего значения к меньшему, т.е. при вводе шага имеет значение только его модуль.
## Пустой datain.txt
### Во второй программе требуется реализовать чтение из фала. При попытке чтения файл datain.txt не создаётся, поскольку пользователь в состоянии справится с этой тривиальной задачей, а создание пустого файла программой не обосновано.
## Ввод в консоль запятой и большого количества непричастных символов
### В программах 1 и 2 присутствуют строки кода «cin.ignore(std::cin.rdbuf()->in_avail());» и «cin.clear();», которые игнорируют все введённые до этого момента символы и чистят буфер потока перед каждым вводом переменной. Причиной их появления в программах служит наличие цикла while и вероятность ошибки пользователя при вводе переменных. При вводе значений с плавающей точкой через консоль следует использовать исключительно точку. Поскольку при вводе переменных, например: «1,5», в консоли, на частный ввод переменной уходил символ «1», а на все последующие – «5». Таким образом консоль выполняла только одну цепочку событий и выйти из этого бесконечного цикла или остановить его было нельзя.

# Блок-схема алгоритма Программы 1

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/379cb5a4-d664-4a1b-a2d5-c439b19a9e5f)

Рисунок 2 – Блок-схема алгоритма Программы 1

В Программе 1 (Приложение А) пользователю предлагается: ввести интервал табулирования функции, ввести шаг табулирования функции, табулировать функцию, записать табулированную функцию в solution.txt, выйти из программы. После действия (такого как ввод интервала или запись табулированной функции) программа возвращается в меню, чтобы продолжить работу. При правильном последовательном вводе интервала и шага с помощью программы можно табулировать функцию, а после записать данные в файл.

В случае если пользователь:
+ при вводе интервала табулирования функции, выйдет за пределы ОДЗ функции, то интервал не будет считаться введённым, и, пользователю, после уведомления о том, что заданный интервал не удовлетворяет ОДЗ функции, или заданный шаг больше интервала, будет предложено вернуться в меню или ввести интервал заново.
+ введёт шаг табулирования функции меньше интервала, то шаг не будет считаться введённым, и, пользователю, после уведомления о том, что заданный шаг больше интервала, будет предложено вернуться в меню или ввести шаг заново.
+ перейдёт к табуляции функции, не задав предварительно интервал и шаг, то будет выведено сообщение что функция не может быть табулирована.
+ перейдёт к записи табулированной функции в файл, не табулировав предварительно функцию, то программа выведет сообщение о том, что функцию следует табулировать перед тем, как записать в файл.

# Пример работы Программы 1

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/53096a2f-c846-4387-8f02-84fa1f3f5686)

Рисунок 3 – Скриншот консоли Программы 1

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/fcf2f1d0-c7bf-48b7-82f1-8402f2cbc611)

Рисунок 4 – Скриншот записи в файл Программы 1

# Диаграмма и описание механизма взаимодействия классов Программы 2

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/4f783392-0463-4bb7-9490-2c08753545c8)

Рисунок 5 – Диаграмма классов Программы 2

В программе реализованы классы и структура:
+ структура Point (описывает точку табуляции функции), хранящая в себе аргумент функции и её вычисленное значение
+ класс RS (Read and Store) читает данные из файла datain.txt для табуляции функции и хранит их (для подкласса Sol), родительский  класс для наследования (экземпляр этого класса в программе не используется)
+ класс Sol решает поставленную задачу – табуляция функции, дочерний класс для наследования
+ класс DateOut выводит данные (принимает в конструктор аргументом экземпляр класса Sol) в файл dataout.txt
+ 
Класс RS и структура Point находятся в отношении типа has-a (композиция), т.е. класс Point относится к классу RS как его часть.

Классы RS и Sol находятся в отношении типа генерализация (наследование), т.е. все, что справедливо для класса RS справедливо и для класса Sol.

Классы DateOut и Sol находятся в отношении типа зависимость, т.е. класс DateOut ссылается на класс Sol , который в свою очередь не знает о существовании первого. Класс DateOut не хранит указатель на экземпляр класса Sol, как и наоборот, поэтому постоянной связи для ассоциации между ними нет.

# Пример работы Программы 2

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/b672fa9b-dab4-4244-8910-8825bf66499e)

Рисунок 6 – Скриншот файла datain.txt Программы 2

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/1e360865-ace7-49fc-8341-9289dc5fa23e)

Рисунок 7 – Скриншот консоли Программы 2

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/044ef191-04f1-4462-a4cd-c03035eafe41)

Рисунок 8 – Скриншот файла dataout.txt Программы 2

# Диаграмма и описание механизма взаимодействия классов Программы 3

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/e4abba0d-760a-492e-9e9c-afd571bbbe3e)

Рисунок 9 – Диаграмма классов Программы 3

В программе реализованы классы:
+ Pointxy (описывает точку табуляции функции), хранящий в себе аргумент функции и её вычисленное значение для их вывода из класса
+ RS (Read and Store) читает данные из элементов Windows Forms richTextBox`ов для табуляции функции и хранит их (для подкласса Sol), родительский  класс для наследования (экземпляр этого класса в программе не используется)
+ Sol решает поставленную задачу – табуляция функции, дочерний класс для наследования

Классы RS и Pointxy находятся в отношении типа has-a (композиция), т.е. класс Pointxy относится к классу RS как его часть.

Классы RS и Sol находятся в отношении типа генерализация (наследование), т.е. все, что справедливо для класса RS справедливо и для класса Sol. Так же этим классам присуще свойство полиморфизм, которое используется в программе.

Пример работы

![image](https://github.com/DimeLight/Kypca4-cpp-3sem/assets/99740101/cf8f0f67-2e19-4152-9125-9bad763bd43a)

Рисунок 10 – Пример работы Программы 3

# ЗАКЛЮЧЕНИЕ
В курсовой работе были рассмотрены табулирование и исследование функции.

В ходе выполнения были решены все поставленные задачи.

Проведено математическое исследование функции, в ходе которого была найдена область допустимых значений функции и произведены исключения в вводных данных, что позволило исключить ошибки при табулировании и правильно вывести график.

Используя методы структурного программирования, написана программа для табулирования функции. Составлена блок-схема, которая схематично описывает алгоритм решения задачи. Увеличен навык работы со стандартными потоками ввода/вывода в C++.

С помощью иерархии классов была написаны программы табулирования функции в парадигме объектно-ориентированного программирования. Также составлены диаграммы используемых классов. Они наглядно отображают атрибуты классов, операции классов и ограничения, которые накладываются на связи между этими классами. Так же увеличен навык создания и работы с классами в C++. В том числе, был разработан графический интерфейс пользователя с использованием инструментария Windows Forms с помощью использования компонента Chart, позволяющий выполнить задачу табулирования функции с выводом точек табуляции в график. Был также построен график исследуемой функции. В процессе выполнения курсовой работы усовершенствованы навыки программирования на C++. 

# СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ (откуда пылесосил код и всякое)
+ orionll Чистая архитектура. Часть II — Парадигмы программирования / orionll. — Текст : электронный // Хабр : [сайт]. — URL: https://habr.com/ru/post/554474/ (дата обращения: 01.12.2021).
+ Юрий Уроки по С++ / Юрий. — Текст : электронный // Ravesli : [сайт]. — URL: https://ravesli.com/uroki-cpp/ (дата обращения: 03.12.2021).
+ Контроль правильности ввода в int. — Текст : электронный // Cyberforum.ru : [сайт]. — URL: https://www.cyberforum.ru/cpp-beginners/thread359236.html (дата обращения: 04.12.2021).
+ desperius cin_buffer_cleanup.cpp / desperius. — Текст : электронный // GitHubGist : [сайт]. — URL: https://gist.github.com/desperius/6704613 (дата обращения: 04.12.2021).
+ String (C++/CLI и C++/CX). — Текст : электронный // Техническая документация Майкрософт : [сайт]. — URL: https://docs.microsoft.com/ru-ru/cpp/extensions/string-cpp-component-extensions?view=msvc-160 (дата обращения: 05.12.2021).
+ ГОСТ 7.32-2017 СИБИД. — Текст : электронный // Техэксперт : [сайт]. — URL: https://docs.cntd.ru/document/1200157208 (дата обращения: 06.12.2021).
+ Генератор библиографического описания. — Текст : электронный // Библиотеки Тольятти : [сайт]. — URL: https://cls.tgl.ru/generator-bo/ (дата обращения: 16.12.2021)
